---
layout:     post
title:      嵌入式Linux驱动题
subtitle:   嵌入式Linux
date:       2018-04-12
author:     hades
header-img: img/my-blog-picture.jpg
catalog: true
tags:
    - hades
    - 嵌入式
    - 面试
    - Linux 
    - kernel 
    - driver
---

# 嵌入式Linux驱动题

### linux内核里面，内存申请有哪几个函数?

  kmalloc()   __get_free_page()  mempool_create()  


### spinlock自旋锁是如何实现的？

自旋锁在同一时刻只能被最多一个内核任务持有，所以一个时刻只有一个线程允许存在于临界区中。这点可以应用在多处理机器、或运行在单处理器上的抢占式内核中需要的锁定服务。

### 请简单介绍一下Linux中的信号量。

Linux中的信号量是一种睡眠锁。如果有一个任务试图获得一个已被持有的信号量时，信号量会将其推入等待队列，然后让其睡眠。这时处理器获得自由去执行其它代码。当持有信号量的进程将信号量释放后，在等待队列中的一个任务将被唤醒，从而便可以获得这个信号量。

### 一个32位的机器,该机器的指针是多少位?
指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。

### `char* s="AAA";printf("%s",s); s[0]='B'; printf("%s",s);`有什么错？
"AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。 cosnt char*s="AAA"; 然后又因为是常量，所以对是s[0]的赋值操作是不合法的。

### 下面程序结果是？
```
main()
{ 
inta[5]={1,2,3,4,5};   
int*ptr=(int*)(&a+1);   
printf("%d,%d",*(a+1),*(ptr-1));
}

```
结果为：2

`5 *(a+1）`就是a[1]，`*(ptr-1)`就是a[4],执行结果是2，`5 &a+1`不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）` int *ptr=(int *)(&a+1);` 则ptr实际是&(a[5]),也就是`a+5` 原因如下： &a是数组指针，其类型为` int (*)[5]; `而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同 a是长度为5的int数组指针，所以要加`5*sizeof(int) `所以ptr实际是a[5] 但是prt与`(&a+1)`类型是不一样的(这点很重要) 所以prt-1只会减去sizeof(int*) a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].

### 请简述中断和DMA的区别。
DMA：是一种无须CPU的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制，使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而大大提高系统的吞吐率.

中断：是指CPU在执行程序的过程中，出现了某些突发事件时CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。

### 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？
中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求cpu的频率比较底，则用中断效率要高一些。主要是看请求频率。

### 字符型驱动设备怎么创建设备文件？
手动创建：`mknod /dev/led c 250 0`    其中`dev/led `为设备节点 c 代表字符设备 250代表主设备号 0代表次设备号

还有UDEV/MDEV自动创建设备文件的方式，UDEV/MDEV是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后。在  `/etc/init.d/rcS` 脚本文件中会执行`mdev -s `自动创建设备节点。 
